<!DOCTYPE html>
<html lang="en">
  <head>

    <meta charset="utf-8">
    <title>Arduino 433Mhz Receiver -- Reading Keyfobs</title>
    <meta name="description" content="I bought a 433Mhz receiver shield for Arduino as I wanted to experiment with wireless communication, and, as the first application, I built a receiver that can read serial numbers and button status from my garage door opener remote....">
    <meta name="author"      content="Alex Harsányi">
    <meta name="keywords"    content="arduino">
    <meta name="viewport"    content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/svg+xml" href="/img/favicon.svg">
    <link rel="canonical" href="https://alex-hhh.github.io/2018/05/arduino-433mhz-receiver.html">
    <link rel="next" href="/2018/03/interactive-overlays-with-the-racket-plot-package-update.html">
    <link rel="prev" href="/2018/05/workout-editor.html">
    <link href="https://fonts.googleapis.com/css?family=Roboto|Roboto+Condensed|Roboto+Mono&display=swap" rel="stylesheet">
    <!-- Feeds -->
    <link rel="alternate" type="application/atom+xml"
          href="/feeds/all.atom.xml" title="Atom Feed">
    <link rel="alternate" type="application/rss+xml"
          href="/feeds/all.rss.xml" title="RSS Feed">
    <!-- JS -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-110325732-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-110325732-1');
    </script>
  </head>
  <body>
    <nav class="navbar navbar-expand-md navbar-dark bg-dark">
      <div class="container">
        <a href="/index.html" class="navbar-brand">Alex Harsányi</a>

        <button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse"
                data-target="#navbar_collapse" aria-controls="navbar_collapse"
                aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse" id="navbar_collapse">
          <ul class="navbar-nav mr-auto">

            <li class="nav-item dropdown">
              <a href="#"
                 class="nav-link dropdown-toggle"
                 data-bs-toggle="dropdown"
                 aria-expanded="false">
                Tags <b class="caret"></b></a>
              <ul class="dropdown-menu" role="menu" id="tags-menu-content">
                <!-- will be filled in dynamically by custom.js -->
              </ul>
            </li>
            <li>
              <a class="nav-link" href="/About.html">About</a>
            </li> 
            <li>
              <a class="nav-link" href="/tags/arduino.html">Arduino</a>
            </li> 
            <li>
              <a class="nav-link" href="/tags/racket.html">Racket</a>
            </li> 
            <li>
              <a class="nav-link" href="/tags/activitylog2.html">ActivityLog2</a>
            </li> 
          </ul>
        </div>
      </div>
    </nav>

    <div class="container">
      <div class="row">

        <!-- Main column -->
        <!-- NOTE: there is a bug in the web server template renderer which
             indents all items inside if blocks.  This means that we cannot
             put the contents inside an if block, as all the <pre> tags will
             be indented.
          -->
        <div id="content" class=col-md-9>





          <article>
  <header>
    <h1>Arduino 433Mhz Receiver &mdash; Reading Keyfobs</h1>
    <p class='date-and-tags'>
<time datetime="2018-05-19" pubdate="true">2018-05-19</time> :: <span class="tags"><a href="/tags/arduino.html">arduino</a></span></p>
  </header>

<p>I bought a 433Mhz receiver shield for Arduino as I wanted to experiment with wireless communication, and, as the first application, I built a receiver that can read serial numbers and button status from my garage door opener remote.</p>
<!-- more-->

<p>The remote used by the garage door opener is built using the HCS200 chip, which is a code hopping encoder. It used in many remote key-less entry systems and seems to be quite popular: I personally have three key remotes that use this chip, all for different systems. The HCS200 works with digital signals only, i.e. it does not transmit anything, instead, its digital output pin is usually connected to a 433Mhz transmitter directly, to use what is known as <a href="https://en.wikipedia.org/wiki/On-off_keying">On-Off Keying</a> modulation. Up to 4 buttons can be connected tp the chip, these are wired directly to a key on the remote. Pressing any of the buttons causes the chip to continuously transmit a code word and a 433Mhz receiver can read this code word, authenticate it, and &ldquo;act&rdquo; upon it, for example open or close a garage door.</p>

<div style="text-align:center">
 <iframe width="700" height="396" src="https://www.youtube.com/embed/wBQeyzdu_kk" frameborder="0" gesture="media" allow="encrypted-media" allowfullscreen="allowfullscreen"></iframe></div>

<p>Sometimes these chips are also connected to 315Mhz transmitters, I found this to be the case with older remotes. With such a remote, a 315Mhz receiver is needed. If you want to build a received for your own remote it is best to check what frequency it is using for its transmission.</p>

<hr />

<p><strong>NOTE</strong> The chip encrypts a part of its transmission. I do not have the keys for decoding this information, as such the code presented here cannot be used to authenticate the transmissions. It can only be used to identify key remotes based on their serial numbers as well as determining which buttons on the remotes were pressed.</p>

<hr />

<h2 id="the-hardware">The hardware</h2>

<p>To receive the transmissions, I used a 433Mhz Arduino receiver shield. There are many of these on the market, mine is from <a href="https://www.freetronics.com.au/products/receiver#.Wvt3NaqFNhF">Freetronics</a>. I had to solder the stackable headers myself in order to fit it on the Arduino UNO board.</p>

<div class="figure"><img src="/img/a013/433Mhz-shield.jpg" alt="" />
 <p class="caption"></p></div>

<p><strong>Data Pin:</strong> The receiver shield has only one data pin: it reads high when the carrier wave is detected and low when the carrier wave is not detected. The pin is connected to <code>D8</code> on the Arduino, but I also connected it to <code>D2</code> so I can attach an interrupt and receive data that way (this is the orange jumper wire in the picture).</p>

<p><strong>Antenna:</strong> There is also pin connection for the antenna, this is a piece of wire about 15 to 17 cm in length that is attached to a pin on the side (the green wire in the picture). Without an antenna wire, the receiver has very poor performance, so make sure you don&rsquo;t forget about it.</p>

<p><strong>Status LEDs:</strong> The 433Mhz receiver shield was supposed to have two general purpose leds connected to D6 and D7, but these didn&rsquo;t work on the shield I got, perhaps they were faulty. I wired instead two external leds on the breadboard, a green one which lights up for the <strong>preamble</strong> and a red one which lights up when data is received.</p>

<h2 id="data-transmission-overview">Data Transmission Overview</h2>

<p>The 433Mhz transmission uses <a href="https://en.wikipedia.org/wiki/On-off_keying">On-Off Keying</a> modulation, which is a type of <a href="https://en.wikipedia.org/wiki/Amplitude-shift_keying">Amplitude-Shift keying</a> modulation. The two terms are abbreviated as <strong>OOK</strong> and <strong>ASK</strong> respectively, but, in practical terms, what this means is that, to transmit a digital signal of ones and zeros, the 433Mhz carrier wave is ON, or transmitted, when the digital signal is 1 and it is OFF when the digital signal is 0. It looks like this:</p>

<div class="figure"><img src="/img/a013/signal-transmission.svg" alt="" />
 <p class="caption"></p></div>

<p>Theoretically, data can be transmitted directly over the wire simply by controlling the on-off state of the transmitter using a shift register, but this would create problems since long strings of ones or zeros would be difficult to detect by the receiver. Instead, the HCS200 encodes each bit using 3 clock cycles, where a 0 places the digital signal high for 2 clock cycles and low or one clock cycle, while a 1 places the digital signal high for one clock cycle and low for two clock cycles. Here is how it looks:</p>

<div class="figure"><img src="/img/a013/logic-0-1.svg" alt="" />
 <p class="caption"></p></div>

<p>With this encoding, there are no long periods of ON or OFF transmissions, and a receiver can decode the transmission without having to have an accurate clock. For example, to transmit the number 240, which is 11110000 in binary, the signal pattern would look like this:</p>

<div class="figure"><img src="/img/a013/transmit-240.svg" alt="" />
 <p class="caption"></p></div>

<p>In addition to the patterns for 1 and 0, the HCS200 also uses a preamble signal: this signal is a sequence of ON and OFF periods of equal length. Since the encodings for 0 and 1 have different lengths for their ON and OFF periods, the preamble cannot be confused with a regular data and can be used by a receiver to detect the beginning of a transmission.</p>

<p>When it transmits, the HCS200 always sends 66 bits of data in a loop &mdash; the same 66 bits are send repeatedly while the button is pressed. Each individual transmission begins with a <strong>preamble</strong> signal. Following the preamble, there is a <strong>header</strong> time when the transmitter is silent and following the header, the 66 bits of data are sent &mdash; these are encoded as described above. The bits are split in two equal parts: 32 <strong>encrypted bits</strong> and 34 unencrypted bits or <strong>fixed bits</strong> , the contents of the bits are explained in the code word description below. After all the data is transmitted, there is another <strong>guard time</strong> where the transmitter is silent and this may be followed by another transmission:</p>

<div class="figure"><img src="/img/a013/hcs200-transmission.svg" alt="" />
 <p class="caption"></p></div>

<p>Each HCS200 transmission forms a code word with the structure shown below. The encrypted part would need to be decrypted first and contains the sequence counter for the transmitter, which allows the receiver to determine if the received code word is valid or not. Decryption requires a decryption key, which is only known to the manufacturers, without this, the transmitter cannot be authenticated. The unencrypted part, however, contains the transmitter&rsquo;s serial number as well as the status of its buttons (each transmitter can have up to 4 buttons).</p>

<div class="figure"><img src="/img/a013/hcs200-code-word.svg" alt="" />
 <p class="caption"></p></div>

<h2 id="the-software">The Software</h2>

<p>The source code for this project is available on GitHub, in the <a href="https://github.com/alex-hhh/Arduino_433Mhz">Arduino_433Mhz</a>, the sketch is named <code>hcs200</code>. The code sets up an interrupt handling routine for input pin <code>D2</code>, which processes the data from the 433Mhz shield. The main loop just looks for a received code word and prints it out.</p>

<p>The Arduino program begins running with the <code>setup</code> function. This function ensures that the pins are setup correctly, <code>D8</code> and <code>D2</code> as inputs from the 433Mhz shield and <code>D6</code> and <code>D7</code> as outputs to the lets on the breadboard. The setup code also sets up the <code>pin2ISR</code> as the function to be called when data on the input pin <code>D2</code> changes, this function will be called when the input pin changes from 0 to 1 or from 1 to 0.</p>

<div class="brush: c++">
 <div class="source">
  <table class="sourcetable">
   <tbody>
    <tr>
     <td class="linenos">
      <div class="linenodiv">
       <pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span></pre></div></td>
     <td class="code">
      <div>
       <pre><span></span><span class="cp">#define PREAMBLE_LED 7</span>
<span class="cp">#define DATA_LED 6</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">setup</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">Serial</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="mi">38400</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Board has the data bit wired to pin 8, and we bridge it to pin 2 to be</span>
<span class="w">  </span><span class="c1">// able to attach an interrupt.</span>
<span class="w">  </span><span class="n">pinMode</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="n">INPUT</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">pinMode</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">INPUT</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">pinMode</span><span class="p">(</span><span class="n">PREAMBLE_LED</span><span class="p">,</span><span class="w"> </span><span class="n">OUTPUT</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">pinMode</span><span class="p">(</span><span class="n">DATA_LED</span><span class="p">,</span><span class="w"> </span><span class="n">OUTPUT</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">attachInterrupt</span><span class="p">(</span><span class="n">digitalPinToInterrupt</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="w"> </span><span class="n">pin2ISR</span><span class="p">,</span><span class="w"> </span><span class="n">CHANGE</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">"Started listening</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div></td></tr></tbody></table></div>

</div>

<p>The <code>pin2ISR</code> maintains some global state about the state of the receive, since it is invoked each time the digital input changes. First, it maintains <code>rx_state</code>, which records the phase of the receive: <code>RS_NOSYNC</code> when no receive is in progress, <code>RS_PREAMBLE</code> when the preamble is being received, <code>RS_DATA</code> when the actual code word data is being received and <code>RS_COMPLETED</code> indicates that an entire code word has been received.</p>

<p>Received data is stored in <code>rx_buf</code> which is an array of three 32 bit numbers, which can hold a total of 96 bits. The HCS200 sends out only 66 bits, so this buffer is large enough. The next position in the receive buffer is stored in <code>rx_bit_count</code>, but since data is received bit-by-bit, this records the number of bits.</p>

<p>In order to determine what is a &ldquo;long pulse&rdquo; and what is a &ldquo;short pulse&rdquo;, the decoder needs to know the transmission clock period. This is stored in <code>tx_clock</code> and it is determined during the preamble phase which contains transitions every clock period.</p>

<p>Finally, <code>last_timestamp</code> and <code>last_pulse_width</code> are used to keep track of the previous timestamp and pulse width and it is used to decode the bits in the transmission.</p>

<div class="brush: c++">
 <div class="source">
  <table class="sourcetable">
   <tbody>
    <tr>
     <td class="linenos">
      <div class="linenodiv">
       <pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span></pre></div></td>
     <td class="code">
      <div>
       <pre><span></span><span class="k">enum</span><span class="w"> </span><span class="nc">RxState</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">RS_NOSYNC</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">                      </span><span class="c1">// Receiver is inactive</span>
<span class="w">    </span><span class="n">RS_PREAMBLE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w">                    </span><span class="c1">// 50% duty cycle</span>
<span class="w">    </span><span class="n">RS_DATA</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w">                        </span><span class="c1">// DATA is being received</span>
<span class="w">    </span><span class="n">RS_COMPLETED</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="w">                    </span><span class="c1">// Receive complete</span>
<span class="p">};</span><span class="w"></span>

<span class="k">volatile</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">rx_state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RS_NOSYNC</span><span class="p">;</span><span class="w"></span>

<span class="kt">char</span><span class="w"> </span><span class="n">rx_bit_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="kt">uint32_t</span><span class="w"> </span><span class="n">rx_buf</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span><span class="w"></span>

<span class="kt">unsigned</span><span class="w"> </span><span class="n">tx_clock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">last_timestamp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="n">last_pulse_width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
</pre></div></td></tr></tbody></table></div>

</div>

<p>The <code>pin2ISR</code> function is shown below. It first determines the &ldquo;pulse width&rdquo; which is the time since the function was last called, and reads the state of the input pin. It may be useful to review the transmission pattern of the HCS200 to better understand what is happening:</p>

<div class="figure"><img src="/img/a013/hcs200-transmission.svg" alt="" />
 <p class="caption"></p></div>

<p>Depending on the state of the receiver (the <code>rx_state</code> value), the <code>pin2ISR</code> function will do one of the following:</p>

<ul>
 <li>if the receiver is inactive, <code>RS_NOSYNC</code>, it looks for a long pulse width,  this corresponds to a long silence before a transmission. If it finds one,  it puts the receiver in <code>RS_PREAMBLE</code> state.</li>
 <li>In <code>RS_PREAMBLE</code> state, the receiver tries to determine the clock period ,  <code>tx_clock</code>, by averaging the pulse widths. If it determines that the last  pulse width was a long one, it switches the to start receiving the data  bits.</li>
 <li>In <code>RS_DATA</code> state, the receiver tries to decode the received bits. It does  that by looking at the last two pulses: a long pulse followed by a short one  represents a <code>1</code> and a short pulse followed by a long one represents a <code>0</code>  (see how the logic 1 and 0 are encoded by the HCS200). In each case it  stores the bit in the appropriate place in <code>rx_buf</code>. Once all bits are  received, the state is changed to <code>RS_COMPLETED</code>, and the main program loop  can now inspect the received code word. The <code>Classify</code> function is used to  determine if a pulse is short, <code>RB_SHORT</code> or long, <code>RB_LONG</code> this function  is not shown here, it is available in the GitHub repository.</li>
 <li>Note that the function does nothing while the receiver is in <code>RS_COMPLETED</code>  state &mdash; in this state, it waits for the main program loop to read the  received data and to reset the state back to <code>RS_NOSYNC</code>, so a new code word  can be received.</li></ul>

<div class="brush: c++">
 <div class="source">
  <table class="sourcetable">
   <tbody>
    <tr>
     <td class="linenos">
      <div class="linenodiv">
       <pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span>
<span class="normal">42</span>
<span class="normal">43</span>
<span class="normal">44</span>
<span class="normal">45</span>
<span class="normal">46</span>
<span class="normal">47</span>
<span class="normal">48</span>
<span class="normal">49</span>
<span class="normal">50</span>
<span class="normal">51</span>
<span class="normal">52</span>
<span class="normal">53</span>
<span class="normal">54</span></pre></div></td>
     <td class="code">
      <div>
       <pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">pin2ISR</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">timestamp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">micros</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">pulse_width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">timestamp</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">last_timestamp</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">pin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">digitalRead</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">rx_state</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="no">RS_NOSYNC</span><span class="p">:</span><span class="w"></span>
<span class="w">      </span><span class="c1">// "Sync" is a high pulse, folowed by a long low</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">pin</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">pulse_width</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">10000</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">pulse_width</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">50000</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="n">rx_state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RS_PREAMBLE</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="n">tx_clock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">last_pulse_width</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="no">RS_PREAMBLE</span><span class="p">:</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">pulse_width</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">tx_clock</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">           </span><span class="n">tx_clock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">tx_clock</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">pulse_width</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">pin</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">pulse_width</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1000</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="c1">// pulse_width was for a long low, switch to receiving data.</span>
<span class="w">          </span><span class="n">rx_state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RS_DATA</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="n">rx_bit_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="n">memset</span><span class="p">(</span><span class="n">rx_buf</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">rx_buf</span><span class="p">));</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="n">rx_state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RS_NOSYNC</span><span class="p">;</span><span class="w">         </span><span class="c1">// Transmission error</span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="no">RS_DATA</span><span class="p">:</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">pin</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="kt">int</span><span class="w"> </span><span class="n">first</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Classify</span><span class="p">(</span><span class="n">last_pulse_width</span><span class="p">);</span><span class="w"></span>
<span class="w">          </span><span class="kt">int</span><span class="w"> </span><span class="n">second</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Classify</span><span class="p">(</span><span class="n">pulse_width</span><span class="p">);</span><span class="w"></span>
<span class="w">          </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">first</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">RB_LONG</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">second</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">RB_SHORT</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// Received a 1 bit</span>
<span class="w">              </span><span class="kt">int</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rx_bit_count</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span><span class="w"></span>
<span class="w">              </span><span class="n">rx_buf</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;&gt;=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">              </span><span class="n">rx_buf</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="mh">0x80000000</span><span class="p">;</span><span class="w"></span>
<span class="w">              </span><span class="n">rx_bit_count</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="p">}</span><span class="w"></span>
<span class="w">          </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">first</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">RB_SHORT</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">second</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">RB_LONG</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// Received a 0 bit</span>
<span class="w">              </span><span class="kt">int</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rx_bit_count</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span><span class="w"></span>
<span class="w">              </span><span class="n">rx_buf</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;&gt;=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">              </span><span class="n">rx_bit_count</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="p">}</span><span class="w"></span>
<span class="w">          </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">                        </span><span class="c1">// invalid pulse combination</span>
<span class="w">              </span><span class="n">rx_state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RS_NOSYNC</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">rx_bit_count</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">MAX_BITS</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="n">rx_state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RS_COMPLETED</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="n">last_timestamp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">timestamp</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">last_pulse_width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pulse_width</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div></td></tr></tbody></table></div>

</div>

<p>The main program loop is really simple: It sets the leds on and off depending of the state of the receiver (<code>rx_state</code>) and checks if the state is <code>RS_COMPLETED</code>, in which case, it decodes the received data and prints it out to the serial port.</p>

<div class="brush: C++">
 <div class="source">
  <table class="sourcetable">
   <tbody>
    <tr>
     <td class="linenos">
      <div class="linenodiv">
       <pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span></pre></div></td>
     <td class="code">
      <div>
       <pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">loop</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">digitalWrite</span><span class="p">(</span><span class="n">DATA_LED</span><span class="p">,</span><span class="w"> </span><span class="n">rx_state</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">RS_DATA</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">digitalWrite</span><span class="p">(</span><span class="n">PREAMBLE_LED</span><span class="p">,</span><span class="w"> </span><span class="n">rx_state</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">RS_PREAMBLE</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">rx_state</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">RS_COMPLETED</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">rx_bit_count</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">MAX_BITS</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">Hcs200_keycode</span><span class="w"> </span><span class="n">keycode</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="n">Hcs200Decode</span><span class="p">(</span><span class="n">rx_buf</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">keycode</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="n">Hcs200Print</span><span class="p">(</span><span class="o">&amp;</span><span class="n">keycode</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="n">rx_state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RS_NOSYNC</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div></td></tr></tbody></table></div>

</div>

<h2 id="final-thoughts">Final thoughts</h2>

<p>It was an interesting project to figure out how the remote keyfobs transmit the data, but it cannot be used for anything important. The keyfobs can be identified by their serial number and the code knows which buttons were pressed, however, since the encrypted part cannot be decrypted without a decryption key, the keyfobs cannot be authenticated and the receiver can never know if the received key code is authentic or fake.</p>
  <footer>
    <div class="fine-print">© Alex Harsányi, licensed under
      <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a>
      , and there's a <a href="/Cookies.html">cookie policy</a>.
    </div>
    <div class="row justify-content-center">
      <nav aria-label="Page Navigation">
        <ul class="pagination">
          <li class="page-item">
            <a class="page-link" href="/2018/03/interactive-overlays-with-the-racket-plot-package-update.html"
               aria-label="Previous">
              <span aria-hidden="true">&larr; Interactive Overlays With the Racket Plot Package &mdash; Update</span>
            </a>
          </li>
          <li class="page-item">
            <a class="page-link" href="/2018/05/workout-editor.html"
               aria-label="Next">
              <span aria-hidden="true">Running and Cycling Workout Editor &rarr;</span>
            </a>
          </li>
        </ul>
      </nav>
    </div>
  </footer>
</article>
        </div>
        <div id="sidebar-content" class="col-md-3">
          <!-- will be filled in dynamically by custom.js -->
        </div>

      </div>

    </div>
  </body>
  <script src="/main.js"></script>
</html>