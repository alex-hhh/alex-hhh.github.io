<!DOCTYPE html>
<html lang="en">
  <head>

    <meta charset="utf-8">
    <title>Arduino Inclinometer</title>
    <meta name="description" content="My brother-in-law got himself a 4WD and wanted an inclinometer module to display the roll and pitch of the vehicle while going on his adventures. I build one using an Arduino Nano and an accelerometer module....">
    <meta name="author"      content="Alex HarsÃ¡nyi">
    <meta name="keywords"    content="arduino">
    <meta name="viewport"    content="width=device-width, initial-scale=1.0">
    <link rel="icon"      href="/favicon.ico">
    <link rel="canonical" href="http://alex-hhh.github.io/2017/12/arduino-inclinometer.html">
    <link rel="next" href="/2017/11/fatigue-and-running-form.html">
    <link rel="prev" href="/2017/12/running-and-outdoor-temperature.html">
    <!-- CSS -->
    <link rel="stylesheet" type="text/css" href="/css/bootstrap.min.css">
    <link rel="stylesheet" type="text/css" href="/css/pygments.css">
    <link rel="stylesheet" type="text/css" href="/css/scribble.css">
    <link rel="stylesheet" type="text/css" href="/css/custom.css">
    <link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet">
    <!-- Feeds -->
    <link rel="alternate" type="application/atom+xml"
          href="/feeds/all.atom.xml" title="Atom Feed">
    <link rel="alternate" type="application/rss+xml"
          href="/feeds/all.rss.xml" title="RSS Feed">
    <!-- JS -->
    <script type="text/javascript">
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-110325732-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>
  <body>
    <!-- A standard Twitter Bootstrap nav bar -->
    <header class="navbar navbar-default navbar-inverse"
            role="banner">
      <div class="container">
        <div class="navbar-header">
          <button type="button"
                  class="navbar-toggle"
                  data-toggle="collapse"
                  data-target=".our-nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a href="/index.html" class="navbar-brand">Alex Harsanyi</a>
        </div>
        <div class="collapse navbar-collapse our-nav-collapse"
             role="navigation">
          <ul class="nav navbar-nav">

            <li class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown">
                Tags <b class="caret"></b></a>
              <ul class="dropdown-menu">
                <li><a href="/index.html">All Posts</a></li>

<li><a href="/tags/activitylog2.html">activitylog2&nbsp;
  <small>(3)</small></a></li>

<li><a href="/tags/arduino.html">arduino&nbsp;
  <small>(3)</small></a></li>

<li><a href="/tags/bike-trainer.html">bike trainer&nbsp;
  <small>(1)</small></a></li>

<li><a href="/tags/racket.html">racket&nbsp;
  <small>(8)</small></a></li>

<li><a href="/tags/training-data-analysis.html">training data analysis&nbsp;
  <small>(5)</small></a></li>
              </ul>
            </li>
            <li>
              <a href="/About.html">About</a>
            </li> 
            <li>
              <a href="/tags/arduino.html">Arduino</a>
            </li> 
            <li>
              <a href="/tags/racket.html">Racket</a>
            </li> 
            <li>
              <a href="/tags/activitylog2.html">ActivityLog2</a>
            </li> 
          </ul>
        </div>
      </div>
    </header>
    <div class="container">
      <div class="row">

        <!-- Main column -->
        <!-- NOTE: there is a bug in the web server template renderer which
             indents all items inside if blocks.  This means that we cannot
             put the contents inside an if block, as all the <pre> tags will
             be indented.
          -->
        <div id="content" class=col-md-9>





          <article>
  <header>
    <h1>Arduino Inclinometer</h1>
    <p class='date-and-tags'>
<time datetime="2017-12-09" pubdate="true">2017-12-09</time> :: <span class="tags"><a href="/tags/arduino.html">arduino</a></span></p>
  </header>

<p>My brother-in-law got himself a 4WD and wanted an inclinometer module to display the roll and pitch of the vehicle while going on his adventures. I build one using an Arduino Nano and an accelerometer module.</p>
<!-- more-->

<hr />

<p><strong>Update 10 Mar 2018</strong> There is an updated <a href="/2018/03/arduino-inclinometer-improvements.html">blog post</a> with some improvements I made to the unit. If you liked this blog post, you might want to have a look at that one as well.</p>

<hr />

<div style="text-align:center">
 <iframe width="560" height="315" src="https://www.youtube.com/embed/TYN2xvI9mGE" frameborder="0" gesture="media" allow="encrypted-media" allowfullscreen="allowfullscreen"></iframe></div>

<p>I found another Arduino based inclinometer project <a href="https://thepajerosport.com/2017/04/14/diy-arduino-inclinometer/">here</a>, but, while I liked the design and component list, the actual Arduino sketch (program) was written in such a way that it required the actual accelerometer unit to be installed flat inside the vehicle and with the X axis of the unit facing forward. The accuracy of the roll and pitch readings depended on how precisely the unit is mounted inside the vehicle.</p>

<p>The model that I built uses the same parts list, but the Arduino Sketch can determine the orientation of the unit, so the unit can be installed in any position inside the vehicle: mine was attached with a piece of Velcro tape to the dash board.</p>

<p>Since the unit can be mounted in any position, the &ldquo;down&rdquo; direction read from the accelerometer will not be a reading of 1 for the Z axis, instead it will be an arbitrary reading of the X, Y, and Z axis values. When the unit is powered up, it will determine its &ldquo;down&rdquo; direction &mdash; this requires the vehicle to be on a flat surface. Once it knows the down direction it can determine the forward direction when the vehicle moves forward, as some acceleration applied to the unit. The forward direction can also be acquired by starting to move the vehicle and than immediately braking hard. With the &ldquo;down&rdquo; and &ldquo;forward&rdquo; directions acquired the unit can now interpret any accelerometer reading relative to these directions so it is being able to correctly determine the pitch and roll and display it.</p>

<h2 id="source-code">Source Code</h2>

<p>The source code for the project is available on <a href="https://github.com/alex-hhh/Arduino_Inclinometer">GitHub</a>. The working of the program is explained in the &ldquo;The Arduino Sketch Explained&rdquo; section below.</p>

<p>To successfully compile the sketches in this project, the following libraries need to be installed in the <a href="https://www.arduino.cc/en/Main/Software">Adruino IDE</a>. I used version 1.8.5 of the IDE, but any later version should work. To install a library, go to the <em>Library Manager</em> use the &ldquo;Sketch/Include Library/Manage Libraries&hellip;&rdquo; menu.</p>

<ul>
 <li><a href="https://github.com/adafruit/Adafruit_Sensor">Adafruit Unified Sensor</a> &mdash;  this is the sensor library requied by the ADXL345 library</li>
 <li><a href="https://github.com/adafruit/Adafruit_ADXL345">Adafruit ADXL345</a> &mdash; this  library communicates with the accelerometer module.</li>
 <li><a href="https://github.com/adafruit/Adafruit-GFX-Library">Adafruit GFX Library</a> &mdash;  this library is the base graphics library for drawing on the OLED display</li>
 <li><a href="https://github.com/adafruit/Adafruit_SSD1306">Adafruit SSD1306</a> &mdash; the  display driver for the specific OLED display used in this project.</li></ul>

<p>In addition to this, the <code>Adafruit_SSD1306.h</code> header file needs to be updated to enable the<code>SSD1306_128_64</code> define, since this project uses an 128 x 64 pixel OLED display. This file can be found in the library folder. On Windows, libraries are installed in the &ldquo;Documents/Arduino/libraries&rdquo; folder.</p>

<h2 id="parts-list">Parts List</h2>

<div class="figure"><img src="/img/a006/inclinometer_finished.jpg" alt="" />
 <p class="caption"></p></div>

<p>This is how the final unit looks. I bought a plastic enclosure to hold the PCB and modules and had to make cutouts for the screen and the buzzer module which would not fit inside the enclosure I got. The following parts are used by this project:</p>

<ul>
 <li><a href="https://store.arduino.cc/usa/arduino-nano">Arduino Nano</a> or compatible  (ATmega328P microcontroller)</li>
 <li>OLED&ndash;12864 &mdash; 0.96 Inch White SPI OLED Display Module, based on the SSD1306  chip</li>
 <li>GY&ndash;291 &mdash; ADXL345 Digital Triple Axis Accelerometer Module &mdash; this module  determines the orientation of the unit and is used to determine the roll and  pitch angles.</li>
 <li>3.5&ndash;5.5V Passive Buzzer Module For Arduino &mdash; this is used to sound an alarm  when the roll or pitch angles exceed certain values</li></ul>

<h2 id="connecting-things-together">Connecting things together</h2>

<div class="figure"><img src="/img/a006/inclinometer_breadboard.jpg" alt="" />
 <p class="caption"></p></div>

<p>Before soldering things together, it is a good idea to first connect all components on a bread board and made sure everything was working properly. The actual connections between all the components are listed below.</p>

<h3 id="arduino-nano-connections">Arduino Nano Connections</h3>

<ul>
 <li><code>A4</code> connected to ADXL345 <code>SDA</code> pin</li>
 <li><code>A5</code> connected to ADXL345 <code>SCL</code> pin</li>
 <li><code>D3</code> connected to OLED <code>DC</code> pin</li>
 <li><code>D4</code> connected to OLED <code>RES</code> pin</li>
 <li><code>D5</code> connected to OLED <code>SDA</code> pin</li>
 <li><code>D6</code> connected to OLED <code>SCL</code> pin</li>
 <li><code>D8</code> connected to the BUZZER <code>SIG</code> pin</li></ul>

<h3 id="adxl345-accelerometer-connections">ADXL345 Accelerometer Connections</h3>

<ul>
 <li><code>GND</code> connected to ground</li>
 <li><code>VCC</code> connected to the 3.3 Volt pin on the Arduino Nano</li>
 <li><code>CS</code> connected to 3.3 Volt pin on the Arduino Nano, so the chip is put in  I2C mode.</li>
 <li><code>INT1</code> not connected</li>
 <li><code>INT2</code> not connected</li>
 <li><code>SDO</code> connected to ground (to select I2C address 0x53)</li>
 <li><code>SDA</code> connected to the <code>A4</code> pin on the Arduino Nano</li>
 <li><code>SCL</code> connected to the <code>A5</code> pin on the Arduino Nano</li></ul>

<h3 id="oled-display-connections">OLED Display Connections</h3>

<ul>
 <li><code>GND</code> connected to ground</li>
 <li><code>VCC</code> connected to 3.3 Volt pin on the Arduino Nano</li>
 <li><code>SCL</code> connected to the <code>D6</code> pin on the Arduino Nano</li>
 <li><code>SDA</code> connected to the <code>D5</code> pin on the Arduino Nano</li>
 <li><code>RES</code> connected to the <code>D4</code> pin on the Arduino Nano</li>
 <li><code>DC</code> connected to the <code>D3</code> pin on the Arduino Nano</li></ul>

<h3 id="buzzer-module-connections">Buzzer Module Connections</h3>

<ul>
 <li><code>SIG</code> pin connected to the <code>D8</code> pin on the Arduino Nano</li>
 <li><code>VCC</code> pin connected to the 3.3 Volt pin on the Arduino Nano</li>
 <li><code>GND</code> pin connected to ground</li></ul>

<h2 id="calibration">Calibration</h2>

<p>To increase the accuracy of the accelerometer, a static calibration needs to be done. Here is why: for each axis, the accelerometer can read a value between &ndash;1024 and +1024. The maximum acceleration range can be specified at initialization time, and for this application is set to 4 G. This means that, when 4 G of acceleration is applied to one of the X, Y or Z axes, the accelerometer should read 1024 (if 4 G is applied in the opposite direction, it should read &ndash;1024). If 1G is applied to the same axis, the accelerometer should read 1024/4 = 256.</p>

<p>The 1 G case is easy to test, since this is the Earths gravity. If you place the accelerometer flat on the table, 1 G of acceleration is applied to the Z axis, and zero acceleration on the X (forward) and Y (left) axis. If I do this experiment with my unit I get the following readings: &ldquo;X = 5; Y = &ndash;27; Z = 226&rdquo;. In fact, no matter how much I adjust the position of the accelerometer, I was never able to obtain the expected &ldquo;X = 0; Y = 0; Z = 256&rdquo; reading.</p>

<p>The calibration process obtains two adjustment values for each axis, a <strong>slope</strong> and an <strong>intercept</strong>. These values are used to adjust the value read from the accelerometer so that it will read &ndash;256 if &ndash;1 G is applied to an axis and +256 if +1 G is applied to that axis.</p>

<p>The calibration process described here is somewhat simplistic, but it works in this case because it is used to determine roll and pitch when there is little or no acceleration applied above the Earths gravity. The advantage of this process is that it is simple enough to perform and requires no extra tools or calibration rig. If the accelerometer is used to actually measure larger accelerations, a different process will need to be used &mdash; you will need to search the net for a better process.</p>

<h3 id="how-to-perform-the-calibration-and-determine-the-slope-and-intercept">How to perform the calibration and determine the slope and intercept</h3>

<p><strong>NOTE:</strong> calibration should be performed after the unit has been assembled and soldered on the final PCB, as soldering will change the calibration values.</p>

<div class="figure"><img src="/img/a006/inclinometer_assembled.jpg" alt="" />
 <p class="caption"></p></div>

<p>The <a href="https://github.com/alex-hhh/Arduino_Inclinometer/blob/master/calibration/calibration.ino">calibration sketch</a> can help with the calibration process. This sketch prints out the raw accelerometer readings for the X, Y and Z axis. To view the values, open the serial monitor window on the Arduino IDE and make sure the serial speed is set to 38400 baud.</p>

<p>With this sketch running, six readings must be obtained from the accelerometer, two for each axis. The accelerometer module has the X and Y axes printed on the PCB, it may help to locate them now. Here are the six readings, when the accelerometer is placed:</p>

<ol>
 <li>flat on the table (Z axis pointing up), adjust it until you obtain the  maximum reading for the Z axis and make a note of it.</li>
 <li>upside down on the table (Z axis pointing down), adjust it until you obtain  the minimum reading for the Z axis and make a note of it.</li>
 <li>standing on the table (X axis pointing up), read the maximum value for the  X axis</li>
 <li>standing upside-down on the table (X axis pointing down), read the minimum  value for the X axis</li>
 <li>sideways on the table (Y axis pointing up), read the maximum value for the  Y axis</li>
 <li>sideways upside-down on the table (Y axis pointing down), read the minimum  value for the Y axis</li></ol>

<p>Than, for each axis, a <strong>slope</strong> and <strong>intercept</strong> value can be calculated using the following formulas:</p>

<pre><code>slope = 2 / (max_reading - min_reading)
intercept = 1 - slope * min_reading
</code></pre>

<p>For my accelerometer unit, I had the following readings and <strong>slope</strong> and <strong>intercept</strong> values:</p>

<div class="table-responsive">
 <table class="table table-striped table-hover">
  <thead>
   <tr>
    <td style="text-align: center">Axis</td>
    <td style="text-align: right">Min Reading</td>
    <td style="text-align: right">Max Reading</td>
    <td style="text-align: right">Slope</td>
    <td style="text-align: right">Intercept</td></tr></thead>
  <tbody>
   <tr>
    <td style="text-align: center">X</td>
    <td style="text-align: right">&ndash;245</td>
    <td style="text-align: right">258</td>
    <td style="text-align: right">0.003976143</td>
    <td style="text-align: right">&ndash;0.02584493</td></tr>
   <tr>
    <td style="text-align: center">Y</td>
    <td style="text-align: right">&ndash;275</td>
    <td style="text-align: right">232</td>
    <td style="text-align: right">0.003944773</td>
    <td style="text-align: right">0.084812623</td></tr>
   <tr>
    <td style="text-align: center">Z</td>
    <td style="text-align: right">&ndash;275</td>
    <td style="text-align: right">230</td>
    <td style="text-align: right">0.003960396</td>
    <td style="text-align: right">0.089108911</td></tr></tbody></table></div>

<p>The slope and intercept values for each axis must be placed in the <a href="https://github.com/alex-hhh/Arduino_Inclinometer/blob/master/inclinometer/inclinometer.ino">inclinometer.ino</a> file, replacing the values that are already present there. The &ldquo;calibration parameters&rdquo; section is shown below:</p>

<div class="brush: C++">
 <table class="sourcetable">
  <tbody>
   <tr>
    <td class="linenos">
     <div class="linenodiv">
      <pre>1
2
3
4
5
6
7
8
9</pre></div></td>
    <td class="code">
     <div class="source">
      <pre><span></span><span class="c1">// Calibration parameters.  These will need to be updated for each unit, see</span>
<span class="c1">// the Calibration section in README.md</span>

<span class="cp">#define X_SLOPE 0.003976143</span>
<span class="cp">#define X_INTERCEPT -0.02584493</span>
<span class="cp">#define Y_SLOPE 0.003944773</span>
<span class="cp">#define Y_INTERCEPT 0.084812623</span>
<span class="cp">#define Z_SLOPE 0.003960396</span>
<span class="cp">#define Z_INTERCEPT 0.089108911</span>
</pre></div>
</td></tr></tbody></table>
</div>

<h2 id="the-arduino-sketch-explained">The Arduino Sketch Explained</h2>

<p>The full sketch source is available here: <a href="https://github.com/alex-hhh/Arduino_Inclinometer/blob/master/inclinometer/inclinometer.ino">https://github.com/alex-hhh/Arduino_Inclinometer/blob/master/inclinometer/inclinometer.ino</a></p>

<p>To understand how the program works, some basic understanding of <a href="https://en.wikipedia.org/wiki/Vector_algebra">vector algebra</a> is required. We read from the accelerometer three values, the acceleration on the X (forward &mdash; backward), Y (left &mdash; right) and Z (up &mdash; down) axes. Together, these values from a single 3 - dimensional, or 3 D, vector. The following operations are defined on vectors in the code.</p>

<p>The <code>vlen</code> function calculates the length, or magnitude, of a 3 D vector. In our case, this represents the absolute acceleration applied to the unit, regardless of the direction. If the unit is at rest, the <code>vlen</code> of any accelerometer reading should be 1, as 1 G of acceleration is applied to the unit regardless of its orientation.</p>

<p>The <code>vnormalize</code> function returns a new vector with the same direction as the original one, but with a length of 1, also called a <em>unit vector</em>.</p>

<p>The <code>vdot</code> function calculates the <a href="https://en.wikipedia.org/wiki/Dot_product">dot product</a> of two vectors. The dot product has an important property for our application: the dot product of two <em>unit vectors</em> represents the cosine of the angle between the two vectors. This means we can determine the angle the unit is facing by using the dot product of the accelerometer reading and the &ldquo;down direction&rdquo; vector, which is (0, 0, 1).</p>

<p>The <code>vcross</code> function calculates the <a href="https://en.wikipedia.org/wiki/Cross_product">cross product</a> of two vectors. The cross product has an important property for our application: the cross product of two vectors results in a vector that is perpendicular (at a right angle) to the plane of the first two vectors. This means we can determine a true forward direction even though, when accelerating the vehicle the vector read from the accelerometer will not point exactly forward or backward.</p>

<h3 id="reading-an-orientation-vector-from-the-accelerometer-module">Reading an orientation vector from the accelerometer module</h3>

<p>The accelerometer values can be read using the <code>getX</code>, <code>getY</code> and <code>getZ</code> methods of the <code>adxl345</code> module, however these are raw, uncalibrated values (see <em>Calibration</em> section above) and the values fluctuate very quickly by small amounts. Using these values directly would result in the angle reading always flickering the last digit when displayed.</p>

<p>The <code>read_accelerometer</code> function defined below reads the values from the accelerometer as a 3 D vector, but applies the calibration <em>slope</em> and <em>intercept</em> values and than filters them using a <a href="https://en.wikipedia.org/wiki/Low-pass_filter">low pass filter</a>. Unlike a rolling average filter, a low pass filter only requires a single extra vector to be kept in the global state. This is important, as the sketch uses up almost all the memory on the Arduino Nano board.</p>

<div class="brush: c++">
 <table class="sourcetable">
  <tbody>
   <tr>
    <td class="linenos">
     <div class="linenodiv">
      <pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28</pre></div></td>
    <td class="code">
     <div class="source">
      <pre><span></span><span class="kt">void</span> <span class="nf">read_accelerometer</span><span class="p">(</span><span class="kt">float</span> <span class="n">output</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="p">{</span>
    <span class="c1">// The filtered accelerometer values.  This is &#39;static&#39;, so it remembers</span>
    <span class="c1">// its values between `read_accelerometer&#39; calls.</span>
    <span class="k">static</span> <span class="kt">float</span> <span class="n">filter</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>

    <span class="c1">// Step 1: read the raw values from the accelerometer</span>
    <span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">adxl345</span><span class="p">.</span><span class="n">getX</span><span class="p">();</span>
    <span class="n">output</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">adxl345</span><span class="p">.</span><span class="n">getY</span><span class="p">();</span>
    <span class="n">output</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">adxl345</span><span class="p">.</span><span class="n">getZ</span><span class="p">();</span>

    <span class="c1">// Step 2: calibrate the values, see the readme.md file</span>
    <span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">X_SLOPE</span> <span class="o">+</span> <span class="n">X_INTERCEPT</span><span class="p">;</span>
    <span class="n">output</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">Y_SLOPE</span> <span class="o">+</span> <span class="n">Y_INTERCEPT</span><span class="p">;</span>
    <span class="n">output</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">Z_SLOPE</span> <span class="o">+</span> <span class="n">Z_INTERCEPT</span><span class="p">;</span>

    <span class="c1">// Step 3: calculate the filter alpha value and update the filter.</span>
    <span class="kt">float</span> <span class="n">alpha</span> <span class="o">=</span> <span class="kt">float</span><span class="p">(</span><span class="n">delta_time</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">LPF_ALPHA</span> <span class="o">+</span> <span class="kt">float</span><span class="p">(</span><span class="n">delta_time</span><span class="p">));</span>

    <span class="n">filter</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">filter</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">alpha</span><span class="p">)</span> <span class="o">+</span> <span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">alpha</span><span class="p">;</span>
    <span class="n">filter</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">filter</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">alpha</span><span class="p">)</span> <span class="o">+</span> <span class="n">output</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">alpha</span><span class="p">;</span>
    <span class="n">filter</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">filter</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">alpha</span><span class="p">)</span> <span class="o">+</span> <span class="n">output</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">alpha</span><span class="p">;</span>

    <span class="c1">// Step 4: produce the final calibrated and filtered values.</span>
    <span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">filter</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="n">output</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">filter</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
    <span class="n">output</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">filter</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table>
</div>

<h3 id="acquiring-the-down-direction">Acquiring the down direction</h3>

<p>When the unit is started up, it needs to determine its orientation and the first step of that is do determine what accelerometer reading represents the &ldquo;down&rdquo; direction. To do that, it assumes that the unit is not moving and the vehicle is on a flat surface (note that most roads have a 2 &ndash; 3 degree camber, so the side of the road is not a flat surface).</p>

<p>The down direction is stored in the global <code>zaxis</code> vector. Each reading, the function checks if the dot product between the <code>zaxis</code> and the current reading, <code>cal</code>, is approximately 1. Since <code>cos(0)</code> is 1, a dot product of 1 means the angle between <code>zaxis</code> and <code>cal</code> is 0, so the two vectors point in the same direction. In our case, this means that we had multiple readings of the same &ldquo;down&rdquo; direction. Note that this assumes that both <code>zaxis</code> and <code>cal</code> are <em>unit vectors</em>, which will be the case if the vehicle is stationary and only the Earths gravity is applied to it.</p>

<p>If <code>cal</code> and <code>zaxis</code> are not pointing in the same direction, the <code>zaxis</code> is updated to be &ldquo;between&rdquo; the previous <code>zaxis</code> and the new <code>cal</code> reading. Effectively, <code>zaxis</code> is slowly moved towards the <code>cal</code> reading.</p>

<div class="brush: c++">
 <table class="sourcetable">
  <tbody>
   <tr>
    <td class="linenos">
     <div class="linenodiv">
      <pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18</pre></div></td>
    <td class="code">
     <div class="source">
      <pre><span></span><span class="kt">void</span> <span class="nf">on_acquire_down_direction</span><span class="p">(</span><span class="kt">float</span> <span class="n">cal</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="p">{</span>
    <span class="kt">float</span> <span class="n">dot</span> <span class="o">=</span> <span class="n">vdot</span><span class="p">(</span><span class="n">cal</span><span class="p">,</span> <span class="n">zaxis</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">dot</span> <span class="o">&gt;</span> <span class="mf">0.99</span> <span class="o">&amp;&amp;</span> <span class="n">dot</span> <span class="o">&lt;</span> <span class="mf">1.01</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vnormalize</span><span class="p">(</span><span class="n">zaxis</span><span class="p">,</span> <span class="n">zaxis</span><span class="p">);</span>

        <span class="c1">// Got our down direction, we can now determine the forward direction.</span>
        <span class="n">SET_STATE</span><span class="p">(</span><span class="n">STATE_ACQUIRE_FORWARD_DIRECTION</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">zaxis</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">zaxis</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">cal</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">;</span>
        <span class="n">zaxis</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">zaxis</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">cal</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">;</span>
        <span class="n">zaxis</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">zaxis</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">cal</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">;</span>

        <span class="c1">// Show a message on the screen that we are acquiring the down</span>
        <span class="c1">// direction.</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table>
</div>

<h3 id="acquiring-the-forward-direction">Acquiring the forward direction</h3>

<p>Once the &ldquo;down&rdquo; direction is known, the forward direction can be determined by moving the vehicle forward. In that case, the accelerometer vector will have a length greater than 1 (in our case we check for 1.02). The &ldquo;length&rdquo; of the vector represents the total acceleration applied to the unit, 1 G is always applied because of Earths gravity and 0.02 is applied from the vehicles acceleration. The acceleration vector will also point slightly backwards now, since the vehicle&rsquo;s forward acceleration is combined with the &ldquo;down&rdquo; acceleration from gravity.</p>

<p><strong>NOTE:</strong> it is also possible to start moving the vehicle and brake hard to get a negative acceleration (deceleration). The end result is the same.</p>

<p>We now have two reference vectors, one that points down, <code>zaxis</code>, and one that points down and slightly backwards. The <em>cross product</em> of these two vectors is a vector that points straight to the left of the unit, this is the <code>yaxis</code>. Finally, the <em>cross product</em> between the <code>yaxis</code> and <code>zaxis</code> is a vector that points forward, the <code>xaxis</code>. The two new vectors are also normalized, as the length of the vector produced by the <em>cross product</em> is not necessarily 1.</p>

<div class="brush: c++">
 <table class="sourcetable">
  <tbody>
   <tr>
    <td class="linenos">
     <div class="linenodiv">
      <pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19</pre></div></td>
    <td class="code">
     <div class="source">
      <pre><span></span><span class="kt">void</span> <span class="nf">on_acquire_forward_direction</span><span class="p">(</span><span class="kt">float</span> <span class="n">cal</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="p">{</span>
    <span class="kt">float</span> <span class="n">gforce</span> <span class="o">=</span> <span class="n">vlen</span><span class="p">(</span><span class="n">cal</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">gforce</span> <span class="o">&gt;</span> <span class="mf">1.02</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 0.02 of acceleration indicates that the vehicle is moving and we</span>
        <span class="c1">// can determine the forward direction.  Note that on Earth, the</span>
        <span class="c1">// vehicle will always be subjected to at leas 1g due to gravity</span>
        <span class="c1">// (unless the vehicle is in free fall).</span>
        <span class="n">vcross</span><span class="p">(</span><span class="n">zaxis</span><span class="p">,</span> <span class="n">cal</span><span class="p">,</span> <span class="n">yaxis</span><span class="p">);</span>
        <span class="n">vcross</span><span class="p">(</span><span class="n">yaxis</span><span class="p">,</span> <span class="n">zaxis</span><span class="p">,</span> <span class="n">xaxis</span><span class="p">);</span>
        <span class="n">vnormalize</span><span class="p">(</span><span class="n">xaxis</span><span class="p">,</span> <span class="n">xaxis</span><span class="p">);</span>
        <span class="n">vnormalize</span><span class="p">(</span><span class="n">yaxis</span><span class="p">,</span> <span class="n">yaxis</span><span class="p">);</span>
        <span class="n">SET_STATE</span><span class="p">(</span><span class="n">STATE_RUNNING</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// The vehicle is not accelerating fast enough yet.  Show a message on</span>
        <span class="c1">// the screen instructing the user to move the vehicle forward.</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table>
</div>

<h3 id="main-running-function">Main running function</h3>

<p>The unit has now determined the &ldquo;down&rdquo;, &ldquo;forward&rdquo; and &ldquo;left&rdquo; directions and stored them in the <code>xaxis</code>, <code>yaxis</code> and <code>zaxis</code>. These three vectors are the reference frame of the unit: they form a 3 x 3 matrix which is the &ldquo;local&rdquo; transform. This matrix has the property that any vector multiplied by it will transform the vector from &ldquo;world&rdquo; coordinates into the &ldquo;local&rdquo; coordinates. In local coordinates, down is always (0, 0, 1) and forward is always (1, 0, 0), to it makes it easy to calculate pitch and roll angles.</p>

<p>The <code>on_running</code> function is the main function of the application. It takes an accelerometer reading, <code>cal</code>, transforms it into the local reference frame of the unit, calculates roll and pitch angles and displays them.</p>

<div class="brush: c++">
 <table class="sourcetable">
  <tbody>
   <tr>
    <td class="linenos">
     <div class="linenodiv">
      <pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34</pre></div></td>
    <td class="code">
     <div class="source">
      <pre><span></span><span class="kt">void</span> <span class="nf">on_running</span><span class="p">(</span><span class="kt">float</span> <span class="n">cal</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="p">{</span>
    <span class="c1">// &#39;cal&#39; is in world coordinates, transform it to local coordinates, to</span>
    <span class="c1">// calculate the calibrated roll and pitch.  Note that the vdot() calls</span>
    <span class="c1">// together make a matrix -- vector multiplication.</span>
    <span class="kt">float</span> <span class="n">ncal</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
    <span class="n">ncal</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">vdot</span><span class="p">(</span><span class="n">xaxis</span><span class="p">,</span> <span class="n">cal</span><span class="p">);</span>
    <span class="n">ncal</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">vdot</span><span class="p">(</span><span class="n">yaxis</span><span class="p">,</span> <span class="n">cal</span><span class="p">);</span>
    <span class="n">ncal</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">vdot</span><span class="p">(</span><span class="n">zaxis</span><span class="p">,</span> <span class="n">cal</span><span class="p">);</span>

    <span class="kt">float</span> <span class="n">pitch</span> <span class="o">=</span> <span class="n">calculate_pitch</span><span class="p">(</span><span class="n">ncal</span><span class="p">);</span>
    <span class="kt">float</span> <span class="n">roll</span> <span class="o">=</span> <span class="n">calculate_roll</span><span class="p">(</span><span class="n">ncal</span><span class="p">);</span>
    <span class="kt">float</span> <span class="n">gforce</span> <span class="o">=</span> <span class="n">vlen</span><span class="p">(</span><span class="n">cal</span><span class="p">);</span>

    <span class="c1">// Check for WARN conditions being met and set or clear appropriate flags.</span>
    <span class="c1">// We set the warn flag when an angle exceeds the warn value, but only</span>
    <span class="c1">// clear it when it drops two degrees below that value.  This ensures that</span>
    <span class="c1">// there is no annoying quick on-off buzzer when the inclinometer hovers</span>
    <span class="c1">// around the warn value.</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">roll</span> <span class="o">&gt;</span> <span class="n">ROLL_WARN</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">SET_FLAG</span><span class="p">(</span><span class="n">ROLL_WARN_FLAG</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">roll</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">ROLL_WARN</span> <span class="o">-</span> <span class="mi">2</span><span class="p">))</span> <span class="p">{</span> <span class="c1">// note the -2, hysteresis !</span>
        <span class="n">CLR_FLAG</span><span class="p">(</span><span class="n">ROLL_WARN_FLAG</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">pitch</span> <span class="o">&gt;</span> <span class="n">PITCH_WARN</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">SET_FLAG</span><span class="p">(</span><span class="n">PITCH_WARN_FLAG</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pitch</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">PITCH_WARN</span> <span class="o">-</span> <span class="mi">2</span><span class="p">))</span> <span class="p">{</span> <span class="c1">// note the -2, hysteresis !</span>
        <span class="n">CLR_FLAG</span><span class="p">(</span><span class="n">PITCH_WARN_FLAG</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">display_pitch_roll</span><span class="p">(</span><span class="n">pitch</span><span class="p">,</span> <span class="n">roll</span><span class="p">,</span> <span class="n">gforce</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table>
</div>

<h3 id="calculating-pitch-and-roll">Calculating pitch and roll</h3>

<p>To calculate the pitch and roll angles, we start with a &ldquo;down&rdquo; direction vector that is adjusted for the unit orientation (see previous secton) and we can use the dot product to obtain the cosine of the angle between the vectors, than we use the built-in <code>acos</code> function to get the actual angle back.</p>

<p>For <em>pitch</em> angle, we are interested in the forward - backward angle of the unit, so we keep only the X and Z coordinates from the &ldquo;down&rdquo; vector, <code>cal</code>. This vector has to be normalized to make it a unit vector.</p>

<p>For <em>roll</em> angle, we are interested in the left - right angle of the unit, so we keep the Y and Z coordinates from the &ldquo;down&rdquo; vector, <code>cal</code>. As with the pitch vector, this vector has to be normalized.</p>

<div class="brush: c++">
 <table class="sourcetable">
  <tbody>
   <tr>
    <td class="linenos">
     <div class="linenodiv">
      <pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17</pre></div></td>
    <td class="code">
     <div class="source">
      <pre><span></span><span class="kt">float</span> <span class="nf">calculate_pitch</span><span class="p">(</span><span class="kt">float</span> <span class="n">cal</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="p">{</span>
    <span class="kt">float</span> <span class="n">down</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">};</span>
    <span class="kt">float</span> <span class="n">pitch_dir</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="n">cal</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cal</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="p">};</span>
    <span class="n">vnormalize</span><span class="p">(</span><span class="n">pitch_dir</span><span class="p">,</span> <span class="n">pitch_dir</span><span class="p">);</span>
    <span class="kt">float</span> <span class="n">pitch</span> <span class="o">=</span> <span class="n">vdot</span><span class="p">(</span><span class="n">down</span><span class="p">,</span> <span class="n">pitch_dir</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">rad2deg</span><span class="p">(</span><span class="n">acos</span><span class="p">(</span><span class="n">pitch</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">float</span> <span class="nf">calculate_roll</span><span class="p">(</span><span class="kt">float</span> <span class="n">cal</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="p">{</span>
    <span class="kt">float</span> <span class="n">down</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">};</span>
    <span class="kt">float</span> <span class="n">roll_dir</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cal</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">cal</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="p">};</span>
    <span class="n">vnormalize</span><span class="p">(</span><span class="n">roll_dir</span><span class="p">,</span> <span class="n">roll_dir</span><span class="p">);</span>
    <span class="kt">float</span> <span class="n">roll</span> <span class="o">=</span> <span class="n">vdot</span><span class="p">(</span><span class="n">down</span><span class="p">,</span> <span class="n">roll_dir</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">rad2deg</span><span class="p">(</span><span class="n">acos</span><span class="p">(</span><span class="n">roll</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table>
</div>

<h3 id="possible-improvements">Possible Improvements</h3>

<p>The unit will acquire the down and forward direction each time it is powered up. This is necessary, since it it designed to be moved around instead of being mounted in a fixed place. However, it means that the unit has to be powered up when the vehicle is on a flat surface. A possible improvement is to mount the unit inside the vehicle in a fixed position, perform the calibration only once and store the <code>xaxis</code>, <code>yaxis</code> and <code>zaxis</code> vectors into EEPROM. This way, the unit can simply retrieve these values from the EEPROM.</p>

<p>Another improvement is to place the <em>slope</em> and <em>intercept</em> calibration values in EEPROM, so that the sketch code does not have to change for each unit being built.</p>

<p>The above improvements would be a challenge, as the memory used by the sketch is already too high. When compiling the sketch, I got the following message from the Arduino compiler:</p>

<blockquote>
 <p>Sketch uses 19538 bytes (63%) of program storage space. Maximum is 30720 bytes.</p>
 <p>Global variables use 1737 bytes (84%) of dynamic memory, leaving 311 bytes for local variables. Maximum is 2048 bytes.</p>
 <p>Low memory available, stability problems may occur.</p></blockquote>

<p>The code itself is not very complex and does not use a lot of memory, but the OLED display requires a back buffer to hold the image. Since I used a 128 x 64 pixel display, it required a back buffer of 8192 bits (since the display is monochrome), or 1024 bytes of RAM. Given that the ATmega328P has 2048 bytes of ram, 50% of the memory is used up by the OLED back-buffer.</p>

<p>The remaining 311 bytes for local variables, means that this space is used to hold the stack variables for function calls. If the function call stack is too deep, it will start writing into the global variables, corrupting the program. Fortunately, this is not the case for this sketch, but it does illustrate the problem that adding a display to a small micro-controller will severely reduce the complexity of the programs it can run.</p>

<hr />

<p><strong>Update 10 Mar 2018</strong> There is an updated <a href="/2018/03/arduino-inclinometer-improvements.html">blog post</a> with some improvements I made to the unit. If you liked this blog post, you might want to have a look at that one as well.</p>

<hr />
  <footer>
    <script type="text/javascript">
      !function(d,s,id){
          var js,fjs=d.getElementsByTagName(s)[0];
          if(!d.getElementById(id)){
              js=d.createElement(s);
              js.id=id;
              js.src="//platform.twitter.com/widgets.js";
              fjs.parentNode.insertBefore(js,fjs);
          }
      }(document,"script","twitter-wjs");
    </script>
    <a href="https://twitter.com/share"
       class="twitter-share-button"
       data-url="http://alex-hhh.github.io/2017/12/arduino-inclinometer.html"
       data-dnt="true">
      "Tweet"</a>
    <script type="text/javascript" src="https://apis.google.com/js/plusone.js"></script>
    <g:plusone size="medium" href="http://alex-hhh.github.io/2017/12/arduino-inclinometer.html"></g:plusone>
    <ul class="pager">
    <li class="previous">
      <a href="/2017/12/running-and-outdoor-temperature.html">&larr; <em>Running and Outdoor Temperature</em></a>
    </li>
    <li class="next">
      <a href="/2017/11/fatigue-and-running-form.html"><em>Fatigue and Running Form</em> &rarr;</a>
    </li>
    </ul>
    <script type="text/javascript">
      var disqus_shortname = 'alex-hhh-github-com';
      (function() {
          var dsq = document.createElement('script');
          dsq.type = 'text/javascript';
          dsq.async = true;
          dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
    </script>
    <div id="disqus_thread"></div>
  </footer>
</article>
        </div>
        <!-- Side bar -->
        <div id="sidebar-content" class="col-md-3">
          <h3>Recent Posts</h3>
          <p><a href='/2018/10/chess-game-using-racket-s-pasteboard-part-3.html'>Chess Game Using Racket&rsquo;s Pasteboard (part 3)</a> <small class='date-and-tags'>
        <time datetime="2018-10-29" pubdate="true">2018-10-29</time></small></p>
        <p><a href='/2018/10/chess-game-using-racket-s-pasteboard-part-2.html'>Chess Game Using Racket&rsquo;s Pasteboard (part 2)</a> <small class='date-and-tags'>
        <time datetime="2018-10-19" pubdate="true">2018-10-19</time></small></p>
        <p><a href='/2018/10/chess-game-using-racket-s-pasteboard.html'>Chess Game Using Racket&rsquo;s Pasteboard</a> <small class='date-and-tags'>
        <time datetime="2018-10-12" pubdate="true">2018-10-12</time></small></p>
        <p><a href='/2018/08/racket-data-frame-package.html'>Racket Data Frame Package</a> <small class='date-and-tags'>
        <time datetime="2018-08-05" pubdate="true">2018-08-05</time></small></p>
        <p><a href='/2018/06/a-racket-gui-widget-to-display-maps-based-on-openstreetmap-tiles.html'>A Racket GUI Widget to display maps based on OpenStreetMap tiles</a> <small class='date-and-tags'>
        <time datetime="2018-06-12" pubdate="true">2018-06-12</time></small></p>
        <p><a href='/2018/05/running-and-cycling-workout-editor.html'>Running and Cycling Workout Editor</a> <small class='date-and-tags'>
        <time datetime="2018-05-27" pubdate="true">2018-05-27</time></small></p>
        <p><a href='/2018/05/arduino-433mhz-receiver-reading-keyfobs.html'>Arduino 433Mhz Receiver &mdash; Reading Keyfobs</a> <small class='date-and-tags'>
        <time datetime="2018-05-19" pubdate="true">2018-05-19</time></small></p>
        <p><a href='/2018/03/interactive-overlays-with-the-racket-plot-package-update.html'>Interactive Overlays With the Racket Plot Package &mdash; Update</a> <small class='date-and-tags'>
        <time datetime="2018-03-20" pubdate="true">2018-03-20</time></small></p>
        <p><a href='/2018/03/arduino-inclinometer-improvements.html'>Arduino Inclinometer Improvements</a> <small class='date-and-tags'>
        <time datetime="2018-03-09" pubdate="true">2018-03-09</time></small></p>
        <p><a href='/2018/02/interactive-overlays-with-the-racket-plot-package.html'>Interactive Overlays With the Racket Plot Package</a> <small class='date-and-tags'>
        <time datetime="2018-02-03" pubdate="true">2018-02-03</time></small></p>
        <p><a href='/2018/01/changing-built-in-racket-packages.html'>Changing Built-in Racket Packages</a> <small class='date-and-tags'>
        <time datetime="2018-01-29" pubdate="true">2018-01-29</time></small></p>
        <p><a href='/2018/01/equipment-usage-and-costs.html'>Equipment Usage and Costs</a> <small class='date-and-tags'>
        <time datetime="2018-01-14" pubdate="true">2018-01-14</time></small></p>
        <p><a href='/2017/12/running-and-outdoor-temperature.html'>Running and Outdoor Temperature</a> <small class='date-and-tags'>
        <time datetime="2017-12-21" pubdate="true">2017-12-21</time></small></p>
        <p><a href='/2017/12/arduino-inclinometer.html'>Arduino Inclinometer</a> <small class='date-and-tags'>
        <time datetime="2017-12-09" pubdate="true">2017-12-09</time></small></p>
        <p><a href='/2017/11/fatigue-and-running-form.html'>Fatigue and Running Form</a> <small class='date-and-tags'>
        <time datetime="2017-11-28" pubdate="true">2017-11-28</time></small></p>
        <p><a href='/2017/11/quantifying-fatigue.html'>Quantifying Fatigue</a> <small class='date-and-tags'>
        <time datetime="2017-11-25" pubdate="true">2017-11-25</time></small></p>
        <p><a href='/2017/11/bike-trainer.html'>Bike Trainer</a> <small class='date-and-tags'>
        <time datetime="2017-11-14" pubdate="true">2017-11-14</time></small></p>
        <p><a href='/2017/09/marathon-training-2017-statistics.html'>Marathon Training 2017 Statistics</a> <small class='date-and-tags'>
        <time datetime="2017-09-21" pubdate="true">2017-09-21</time></small></p>
        <p><a href='/2017/09/introducing-activitylog2.html'>Introducing ActivityLog2</a> <small class='date-and-tags'>
        <time datetime="2017-09-15" pubdate="true">2017-09-15</time></small></p>
        </div>
      </div>
      <footer>
        <hr />
        <!-- <p><a href="https://twitter.com/racketlang"
                   class="twitter-follow-button"
                   data-show-count="false"
                   data-lang="en">
                  "Follow RacketLang"
                </a>
                <script type="text/javascript">
                  !function(d,s,id){
                      var js,fjs=d.getElementsByTagName(s)[0];
                      if(!d.getElementById(id)){
                          js=d.createElement(s);
                          js.id=id;
                          js.src="//platform.twitter.com/widgets.js";
                          fjs.parentNode.insertBefore(js,fjs);
                      }
                  }(document,"script","twitter-wjs");
                </script></p> -->
        <p>Site generated
          by <a href="https://github.com/greghendershott/frog">Frog</a>,
          the <strong>fr</strong>ozen bl<strong>og</strong>
          tool. Using <a href="http://twitter.github.com/bootstrap/index.html">Bootstrap</a>. Also
          available as <a href="/feeds/all.atom.xml">Atom</a>
          and <a href="/feeds/all.rss.xml">RSS</a> feeds. . There is also
          a <a href="/Cookies.html">cookie policy</a>.</p>
        <!-- <p><em>Your legal notice here</em>.</p> -->
      </footer>
    </div>
    <!-- </body> JS -->
    <script type="text/javascript" src="//code.jquery.com/jquery.min.js"></script>
    <script type="text/javascript" src="/js/bootstrap.min.js"></script>
  </body>
</html>